#pragma config(Sensor, dgtl1,  f,              sensorDigitalOut)
#pragma config(Sensor, dgtl2,  r,              sensorDigitalOut)
#pragma config(Sensor, dgtl3,  b,              sensorDigitalOut)
#pragma config(Sensor, dgtl4,  l,              sensorDigitalOut)
#pragma config(Sensor, dgtl5,  rightU,         sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  backU,          sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  leftU,          sensorSONAR_mm)
#pragma config(Sensor, dgtl11, frontU,         sensorSONAR_mm)
#pragma config(Motor,  port2,           front,         tmotorVex393, openLoop)
#pragma config(Motor,  port3,           left,          tmotorVex393, openLoop)
#pragma config(Motor,  port4,           right,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           back,          tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This is just so that I have access to this code at both home and uni. I realise that it is quite messy

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//FUNCTION PROTOTYPES
void Drive(char direction);
char CheckMode();
void UltraDemo();
char PickDirection(char currentDirection);
void UltrasonicControl();
void CheckUltrasonic();
void TiltSensorPlusDrive();
void Arcade();
void TankDrive();
void PlusDrive();
void SetLEDs(short fr, short ri, short ba, short le);
bool CompareWarnings();

#define ULTRASONIC_LIMIT 300
#define DRIVE_SPEED 50

/////////////////////////////////////////////////////////////////////////////////////////

//Look, some variables (:

//variables that you are allowed to play with
int deadband1=15; //deadband for joysticks


//variables that you should leave alone
char mode; //value set by CheckMode function, indicates which subprogram the robot is running
char warning[5] ={0,0,0,0,0};
char lastWarning[5]={0,0,0,0,0};


///////////////////////////////////////////////////////////////////////////////////////

//Functions

char CheckMode() {
	if(vexRT[Btn7U]==1) {
		return 1;
		} else if(vexRT[Btn7R]==1) {
		return 2;
		} else if(vexRT[Btn7D]==1) {
		return 3;
		} else if(vexRT[Btn7L]==1) {
		return 4;
		} else if(vexRT[Btn8U]==1) {
		return 5;
		} else if(vexRT[Btn8R]==1) {
		return 6;
		} else if(vexRT[Btn8D]==1) {
		return 7;
		}else if(vexRT[Btn8L]==1) {
		return 8;
		} else {
		return 0;
	}
}

//JOYSTICK CONTROL
void PlusDrive(){ //function for driving plus drive normally. cbf commenting, deal with it.

	while(mode) {
		Drive(0);
		mode=CheckMode();
		wait1Msec(10);
	}

	while(mode==0) {
		if(abs(vexRT[Ch1])>10){
			motor[right]=-sgn(vexRT[Ch1])*((vexRT[Ch1]*vexRT[Ch1])/127);
			motor[left]=sgn(vexRT[Ch1])*((vexRT[Ch1]*vexRT[Ch1])/127);
			motor[front]=sgn(vexRT[Ch1])*((vexRT[Ch1]*vexRT[Ch1])/127);
			motor[back]=-sgn(vexRT[Ch1])*((vexRT[Ch1]*vexRT[Ch1])/127);
			}else{
			motor[right]=sgn(vexRT[Ch3])*((vexRT[Ch3]*vexRT[Ch3])/127);
			motor[left]=sgn(vexRT[Ch3])*((vexRT[Ch3]*vexRT[Ch3])/127);
			motor[front]=sgn(vexRT[Ch4])*((vexRT[Ch4]*vexRT[Ch4])/127);
			motor[back]=sgn(vexRT[Ch4])*((vexRT[Ch4]*vexRT[Ch4])/127);
		}

		mode=CheckMode();
	}

}

//TANK DRIVE
void TankDrive() {

	while(mode) {
		Drive(0);
		mode=CheckMode();
		wait1Msec(10);
	}

	int Channel_1, Channel_2, Channel_3;


	while(!mode) {
		// joystick deadzone
		if (abs(vexRT[Ch1])<15){
			Channel_1 = 0;
		}
		else{
			Channel_1 = sgn(vexRT[Ch1])*((vexRT[Ch1]*vexRT[Ch1])/127);
		}
		if (abs(vexRT[Ch2])<15){
			Channel_2 = 0;
		}
		else{
			Channel_2 = sgn(vexRT[Ch2])*((vexRT[Ch2]*vexRT[Ch2])/127);
		}
		if (abs(vexRT[Ch3])<15){
			Channel_3 = 0;
		}
		else{
			Channel_3 = sgn(vexRT[Ch3])*((vexRT[Ch3]*vexRT[Ch3])/127);
		}

		motor[front] = Channel_3 + Channel_1;
		motor[left] = Channel_3 - Channel_1;
		motor[right] = Channel_2 - Channel_1;
		motor[back] = Channel_2 + Channel_1;

		mode=CheckMode();
	}
}

//ARCADE DRIVE
void Arcade() {

	int Channel_1, Channel_2, Channel_4;

	while(mode) {
		Drive(0);
		mode=CheckMode();
		wait1Msec(10);
	}

	while(!mode) {
		// joystick deadzone
		if (abs(vexRT(Ch1))<15){
			Channel_1 = 0;
		}
		else{
			Channel_1 = sgn(vexRT[Ch1])*((vexRT[Ch1]*vexRT[Ch1])/127);
		}
		if (abs(vexRT(Ch2))<15){
			Channel_2 = 0;
		}
		else{
			Channel_2 = sgn(vexRT[Ch2])*((vexRT[Ch2]*vexRT[Ch2])/127);
		}
		if (abs(vexRT(Ch4))<15){
			Channel_4 = 0;
		}
		else{
			Channel_4 = sgn(vexRT[Ch4])*((vexRT[Ch4]*vexRT[Ch4])/127);
		}

		motor[front] = Channel_2 + Channel_1 + Channel_4;
		motor[left] = Channel_2 - Channel_1 + Channel_4;
		motor[right] = Channel_2 - Channel_1 - Channel_4;
		motor[back] = Channel_2 + Channel_1 - Channel_4;

		mode=CheckMode();
	}
}

//TILT SENSOR CONTROL
void TiltSensorPlusDrive(){ //Function for driving plus drive with tilt sensor control

	//These can be changed
	const float Kf=1; //constant for forwards speeds
	const float Ks=1; //constant for strafe speeds
	const float Kt=1; //constant for turning speeds
	int deadband=20; //deadband for tilt sensor

	//These should be left alone
	float forwardspeedsub; //a variable used in the calculation of forwardspeed. Just ignore it
	float forwardspeed; //rate at which the robot drives forwards
	float turnspeed; //rate at which the robot turns
	float strafesum;
	float strafespeedsub;
	float strafespeed; //rate at which the robot strafes
	const int n=5; //number of spaces in each array; number of steps which are averaged; number of linear filtering steps
	int forwardsum; //sum of the previous n values of the x axis of the tilt sensor
	int i; //used in for loops. grrr
	int x[n]; //array to store the previous n values of x axis of tilt sensor
	int y[n]; //array to store the previous n values of y axis of tilt sensor
	float leftsub;
	float rightsub;
	float frontsub;
	float backsub;
	float Km=1; //coefficient which adjusts all the values so that they don't freak out and become more that 127. Don't play with this. badbadbad
	float highest; //max abs power to any one motor

	while(mode) {
		Drive(0);
		mode=CheckMode();
		wait1Msec(10);
	}

	while(!mode) {
		for(i=(n-1); i>0; i--) {
			x[i]=x[(i-1)]; //moves all the x axis array values down to the next array space (x)
		}
		x[0]=-vexRT[AccelY]; //updates the initial array value to whatever the tilt sensor is currently reading (x axis)

		for (i=(n-1); i>0; i--) {
			y[i]=y[(i-1)]; //moves all the x axis array values down to the next array space (y)
		}
		y[0]=vexRT[AccelX]; //updates the initial array value to whatever the tilt sensor is currently reading (y axis)

		forwardsum=0;
		for(i=0;i<n;i++){
			forwardsum=(forwardsum+x[i]); //sums all the values stored in the x array
		}
		forwardspeedsub=(forwardsum/n); //takes average of the values stored in the x array

		strafesum=0;
		for(i=0;i<n;i++){
			strafesum=(strafesum+y[i]); //sums all the values stored in the y array
		}
		strafespeedsub=(strafesum/n); //takes average of values stored in y array

		forwardspeed=Kf*(sgn(forwardspeedsub)*127*((forwardspeedsub*forwardspeedsub)/10000)); //makes the avg vs output power parabolic rather than linear
		strafespeed=Ks*(sgn(strafespeedsub)*127*((strafespeedsub*strafespeedsub)/10000));
		if(abs(vexRT[Ch1])>deadband1){
			turnspeed=-Kt*(sgn(vexRT[Ch1])*(((vexRT[Ch1])*(vexRT[Ch1]))/127));
			}else{
			turnspeed=0;
		}

		leftsub=forwardspeed-turnspeed;
		rightsub=forwardspeed+turnspeed;
		frontsub=strafespeed-turnspeed;
		backsub=strafespeed+turnspeed;

		highest=abs(leftsub);
		if(abs(rightsub)>highest) {
			highest=abs(rightsub);
		}
		if(abs(frontsub)>highest){
			highest=abs(frontsub);
		}
		if(abs(backsub)>highest){
			highest=abs(backsub);
		}
		if(highest>0 && highest>127){
			Km=127/highest;
			} else {
			Km=1;
		}

		if(Km==0){Km=1;} //somethine is really screwed. This will fix it. This should never happen.

		if(abs(Km*leftsub)>127){
			motor[left]=sgn(Km*leftsub)*127;
			}else if(abs(Km*leftsub)>deadband){
			motor[left]=Km*leftsub; //output to motors vv
			}else{
			motor[left]=0;
		}
		if(abs(Km*rightsub)>127){
			motor[right]=sgn(Km*rightsub)*127;
			}else if(abs(Km*rightsub)>deadband){
			motor[right]=Km*rightsub;
			}else{
			motor[right]=0;
		}
		if(abs(Km*frontsub)>127){
			motor[front]=sgn(Km*rightsub)*127;
			}else if(abs(Km*frontsub)>deadband){
			motor[front]=Km*frontsub;
			}else{
			motor[front]=0;
		}
		if(abs(Km*backsub)>127){
			motor[back]=sgn(Km*backsub)*127;
			}else if(abs(Km*backsub)>deadband){
			motor[back]=Km*backsub;
			}else{
			motor[back]=0;
		}


		wait1Msec(1);

		mode=CheckMode();
	}
}

//SOUNDS TASK
task sounds {

	bool vexnetWasActive=false;

	while(1){
		if(!bVEXNETActive &&vexnetWasActive==true) {
			PlaySoundFile("ohai.wav");
			while(bSoundActive){wait1Msec(1);}
			vexnetWasActive=false;
		}
		if(bVEXNETActive && vexnetWasActive==false) {
			PlaySoundFile("ohai.wav");
			while(bSoundActive){wait1Msec(1);}
			vexnetWasActive=true;
		}

	}
}

//DRIVE IN THIS DIRECTION
void Drive(char direction) {

	switch(direction) {

	case 0: //stop
		motor[port1]=0;
		motor[port2]=0;
		motor[port3]=0;
		motor[port4]=0;
		break;
	case 1: //drive forwards
		motor[left]=DRIVE_SPEED;
		motor[right]=DRIVE_SPEED;
		motor[front]=0;
		motor[back]=0;
		break;
	case 2: //drive right
		motor[front]=DRIVE_SPEED;
		motor[back]=DRIVE_SPEED;
		motor[left]=0;
		motor[right]=0;
		break;
	case 3: //drive backwards
		motor[left]=-DRIVE_SPEED;
		motor[right]=-DRIVE_SPEED;
		motor[front]=0;
		motor[back]=0;
		break;
	case 4: //drive left
		motor[front]=-DRIVE_SPEED;
		motor[back]=-DRIVE_SPEED;
		motor[left]=0;
		motor[right]=0;
		break;
	default: //stop all motors
		motor[port1]=0;
		motor[port2]=0;
		motor[port3]=0;
		motor[port4]=0;
		break;
	}

}

//CHECK A SPECIFIED ULTRASONIC SENSOR
void CheckUltrasonic() {

	for(int j=0; j<5; j++) {
		lastWarning[j]=warning[j];
	}

	if(SensorValue[frontU]<ULTRASONIC_LIMIT && SensorValue[frontU]!=-1) {
		SensorValue[f]=0;
		warning[1] = 1;
		} else {
		warning[1]=0;
		SensorValue[f]=1;
	}
	if(SensorValue[rightU]<ULTRASONIC_LIMIT && SensorValue[rightU]!=-1) {
		SensorValue[r]=0;
		warning[2]=1;
		} else {
		SensorValue[r]=1;
		warning[2]=0;
	}
	if(SensorValue[backU]<ULTRASONIC_LIMIT && SensorValue[backU]!=-1) {
		SensorValue[b]=0;
		warning[3]=1;
		} else {
		warning[3]=0;
		SensorValue[b]=1;
	}
	if(SensorValue[leftU]<ULTRASONIC_LIMIT && SensorValue[leftU]!=-1) {
		SensorValue[l]=0;
		warning[4]=1;
		} else {
		warning[4]=0;
		SensorValue[l]=1;
	}
}


void SetLEDs(short fr, short ri, short ba, short le) {
	SensorValue[f]=!fr;
	SensorValue[r]=!ri;
	SensorValue[b]=!ba;
	SensorValue[l]=!le;
}

//ULTRASONIC FUNCTION
void UltrasonicControl() {

	while(mode) {
		Drive(0);
		mode=CheckMode();
		wait1Msec(10);
	}

	char currentDirection = PickDirection(0);

	while(!mode) {

		Drive(currentDirection);
		CheckUltrasonic();
		if(CompareWarnings()) {
			currentDirection=PickDirection(currentDirection);
		}
		wait10Msec(1);
		mode=CheckMode();
	}
	SetLEDs(0,0,0,0);
}

//PICK A DIRECTION. Picks and returns a random direction (1-4) which is not the direction passed to it
char PickDirection(char currentDirection) {

	char newDirection;
	
	if(warning[1]==1 && warning[2]==1 && warning[3]==1 && warning[4]==1) {
		return 0;
	}

	do {
		newDirection=random(3)+1;
	} while(newDirection==currentDirection || warning[newDirection]);

	return newDirection;
}

//ULTRA SOUND DEMO
void UltraDemo() {

	StopTask(sounds);

	while(mode) {
		Drive(0);
		mode=CheckMode();
		wait1Msec(10);
	}

	while(!mode) {
		float tone=SensorValue[frontU]/2+800;
		PlayTone(tone,10);
		while(bSoundActive) { wait1Msec(1); }
		mode=CheckMode();
	}

	StartTask(sounds);
}

bool CompareWarnings() {
	if(lastWarning[1]==0 && warning[1]==1){
		return true;
	} else if(lastWarning[2]==0 && warning[2]==1) {
		return true;
	} else if(lastWarning[3]==0 && warning[3]==1) {
		return true;
	} else if(lastWarning[4]==0 && warning[4]==1) {
		return true;
	} else {
		return false;
	}
}

///////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{

}

////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

}

/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	SetLEDs(0,0,0,0);
	StartTask(sounds);
	mode=1;

	while (true)
	{
		switch(mode) {

		case 1:
			TankDrive();
			break;
		case 2:
			Arcade();
			break;
		case 3:
			TiltSensorPlusDrive();
			break;
		case 4:
			UltrasonicControl();
			break;
		case 5:
			PlusDrive();
		case 6:
			UltraDemo();
		default:
			Drive(0);
			mode=CheckMode();
			break;
		}
	}
}

//The End
